package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

var (
	inputFile   = flag.String("input", "", "input file name")
	outputFile  = flag.String("output", "", "output file name")
	packageName = flag.String("package", "", "package name of the output file")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of codegen:\n")
	fmt.Fprintf(os.Stderr, "\tcodegen --input [input-file] --output [output-file] --package [package-name]\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	flag.Usage = Usage
	flag.Parse()
	if len(*inputFile) == 0 || len(*outputFile) == 0 || len(*packageName) == 0 {
		Usage()
		return
	}
	// Create the AST by parsing src.
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, *inputFile, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	g := NewGenerator()
	ast.Inspect(f, g.processDecl)
	g.generate(*packageName)
	ret := g.format()
	file, err := os.Create(*outputFile)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	file.Write(ret)
}

type Generator struct {
	buf    bytes.Buffer
	models []TlvModel
	tagRe  *regexp.Regexp
}

func NewGenerator() *Generator {
	return &Generator{
		models: make([]TlvModel, 0),
		tagRe:  regexp.MustCompile(`tlv:"(?P<typ>[0-9a-fA-FxX]+)"`),
	}
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) parseTag(tag *ast.BasicLit) uint64 {
	matches := g.tagRe.FindStringSubmatch(tag.Value)
	if len(matches) <= 1 {
		return 0
	}
	typVal, err := strconv.ParseUint(matches[1], 0, 0)
	if err != nil {
		return 0
	}
	return typVal
}

func (g *Generator) parseDoc(doc *ast.CommentGroup) string {
	const Prefix = "//+field:"
	for _, c := range doc.List {
		if c != nil && strings.HasPrefix(c.Text, Prefix) {
			return c.Text[len(Prefix):]
		}
	}
	return ""
}

func (g *Generator) processDecl(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.TYPE {
		// We only care about const declarations.
		return true
	}
	typSpec, ok := decl.Specs[0].(*ast.TypeSpec)
	if !ok {
		// Skip other declarations
		return false
	}
	stru, ok := typSpec.Type.(*ast.StructType)
	if !ok || stru.Fields == nil {
		// Skip other declarations
		return false
	}
	model := TlvModel{
		Name:   typSpec.Name.Name,
		Fields: make([]*Field, 0),
	}
	for _, f := range stru.Fields.List {
		if len(f.Names) <= 0 {
			continue
		}
		fieldName := f.Names[0].Name
		tlvTypNum := g.parseTag(f.Tag)
		fieldTypeStr := g.parseDoc(f.Doc)
		if tlvTypNum == 0 || fieldTypeStr == "" {
			continue
		}
		// Dispatch to specific fields
		f := ParseField(fieldName, tlvTypNum, fieldTypeStr)
		if f == nil {
			continue
		}
		model.Fields = append(model.Fields, f)
	}
	if len(model.Fields) > 0 {
		g.models = append(g.models, model)
	}

	return false
}

func (g *Generator) generate(packName string) {
	const Temp = `// Generated by the generator, DO NOT modify manually
	package {{.}}
	import (
		"encoding/binary"
		"time"
	)
	`
	t := template.Must(template.New("ModelDecodeFrom").Parse(Temp))
	err := t.Execute(&g.buf, packName)
	if err != nil {
		log.Fatal(err)
	}
	for _, m := range g.models {
		err = m.Generate(&g.buf)
		if err != nil {
			log.Fatal(err)
		}
	}
}
