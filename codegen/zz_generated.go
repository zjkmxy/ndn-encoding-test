// Generated by the generator, DO NOT modify manually
package codegen

import (
	"encoding/binary"
	"time"
)

type MetaInfoEncoder struct {
	length uint
}

func (e *MetaInfoEncoder) init(v *MetaInfo) {
	var l uint = 0
	l += 1
	switch x := v.ContentType; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := uint64(v.FreshnessPeriod / time.Millisecond); {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := len(v.FinalBlockID); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(v.FinalBlockID))
	e.length = l
}

func (e *MetaInfoEncoder) encodeInto(v *MetaInfo, buf []byte) uint {
	var pos uint = 0
	buf[pos] = 24
	pos += 1
	switch x := v.ContentType; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = 25
	pos += 1
	switch x := uint64(v.FreshnessPeriod / time.Millisecond); {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = 26
	pos += 1
	switch x := len(v.FinalBlockID); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], v.FinalBlockID)
	return pos
}

type SignatureInfoEncoder struct {
	length uint
}

func (e *SignatureInfoEncoder) init(v *SignatureInfo) {
	var l uint = 0
	l += 1
	switch x := v.SignatureType; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	e.length = l
}

func (e *SignatureInfoEncoder) encodeInto(v *SignatureInfo, buf []byte) uint {
	var pos uint = 0
	buf[pos] = 27
	pos += 1
	switch x := v.SignatureType; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	return pos
}

type DataEncoder struct {
	length                uint
	Name_length           uint
	MetaInfo_encoder      MetaInfoEncoder
	SignatureInfo_encoder SignatureInfoEncoder
}

func (e *DataEncoder) init(v *Data) {
	e.Name_length = 0
	for _, c := range v.Name {
		e.Name_length += uint(len(c))
	}
	e.MetaInfo_encoder.init(v.MetaInfo)
	e.SignatureInfo_encoder.init(v.SignatureInfo)
	var l uint = 0
	l += 1
	switch x := e.Name_length; {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += e.Name_length
	l += 1
	switch x := e.MetaInfo_encoder.length; {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += e.MetaInfo_encoder.length
	l += 1
	switch x := len(v.Content); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(v.Content))
	l += 1
	switch x := e.SignatureInfo_encoder.length; {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += e.SignatureInfo_encoder.length
	l += 1
	l += 33
	e.length = l
}

func (e *DataEncoder) encodeInto(v *Data, buf []byte) uint {
	var pos uint = 0
	buf[pos] = 7
	pos += 1
	switch x := e.Name_length; {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	for _, c := range v.Name {
		copy(buf[pos:], c)
		pos += uint(len(c))
	}
	buf[pos] = 20
	pos += 1
	switch x := e.MetaInfo_encoder.length; {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	pos += e.MetaInfo_encoder.encodeInto(v.MetaInfo, buf[pos:])
	buf[pos] = 21
	pos += 1
	switch x := len(v.Content); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], v.Content)
	buf[pos] = 22
	pos += 1
	switch x := e.SignatureInfo_encoder.length; {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	pos += e.SignatureInfo_encoder.encodeInto(v.SignatureInfo, buf[pos:])
	buf[pos] = 23
	pos += 1
	buf[pos] = 32
	pos += 33
	return pos
}
